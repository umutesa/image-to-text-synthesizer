# -*- coding: utf-8 -*-
"""CNN_Modal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ct864XoK15Yin_WBCqogYV-0k2dpdRs8
"""

pip install datasets

#---------------------------------IMPORT LIBRARIES------------------------------------

from datasets import load_dataset
import tensorflow as tf
from tensorflow.keras import datasets, layers, models
import matplotlib.pyplot as plt

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import numpy as np

from sklearn.metrics import classification_report

import random
from collections import defaultdict

#------------LOAD DATASET AND SPLIT TRAIN/TEST-----------------------------------------

ds = load_dataset("uoft-cs/cifar100")# Load the CIFAR10 dataset
(train_images, train_labels), (test_images, test_labels) = datasets.cifar10.load_data()
train_images, test_images = train_images / 255.0, test_images / 255.0 #Normalize pixel values to be between 0 and 1

#--------------DEFINE THE CNN MODEL ARCHITECTURE-----------------------------------------------------

model = models.Sequential() #A Simple basic sequential model
model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3)))  # Convolutional Layer by filtering 3x3 matrix - 32 kernel size; Input shape for CIFAR10= 32x 32 with RGB (3)-Color
model.add(layers.MaxPooling2D((2, 2))) #Max pooling 2x2
model.add(layers.Conv2D(64, (3, 3), activation='relu')) #Activation Function - relu for non-linearlity
model.add(layers.MaxPooling2D((2, 2)))
model.add(layers.Conv2D(64, (3, 3), activation='relu'))
model.add(layers.Flatten())  # Flatten the 3D feature maps
model.add(layers.Dense(64, activation='relu')) #64 kernels
model.add(layers.Dense(10, activation='softmax'))  # 10 classes for CIFAR10

#-----------------COMPILE MODEL---------------------------------------------------------------

model.compile(optimizer='adam',loss='sparse_categorical_crossentropy', metrics=['accuracy'])  #define loss function ,  metrices and optimization
model.fit(train_images, train_labels, epochs=10, validation_data=(test_images, test_labels))
test_loss, test_acc = model.evaluate(test_images, test_labels, verbose=2)
print(test_acc)

#-----------------CONFUSION MAATRIX--------------------------

y_pred = model.predict(test_images)
y_pred_classes = np.argmax(y_pred, axis=1)
y_true = test_labels.flatten()
cm = confusion_matrix(y_true, y_pred_classes)
disp = ConfusionMatrixDisplay(confusion_matrix=cm)
disp.plot()
plt.title("Confusion Matrix OF the CNN Modal")
plt.show()

#----------------------ACCURACY PLOT----------------------------------------------------------

predictions = model.predict(test_images)
y_pred_classes = np.argmax(y_pred, axis=1)
y_true = test_labels.flatten()
cm = confusion_matrix(y_true, y_pred_classes)
disp = ConfusionMatrixDisplay(confusion_matrix=cm)
disp.plot()
plt.title("Confusion Matrix")
plt.show()

predicted_classes = np.argmax(predictions, axis=1)
true_classes = test_labels.flatten()


print(classification_report(y_true, y_pred_classes)) #Correction Report

# Show first 5 test images and predictions
for i in range(100):
    plt.imshow(test_images[i])
    plt.title(f"True: {true_classes[i]}, Predicted: {predicted_classes[i]}")
    plt.show()

#------------------------------VALIDATION--------------------------------------------------------------

history = model.fit(train_images, train_labels, epochs=10,validation_data=(test_images, test_labels))
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Val Accuracy')
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Val Loss')
plt.xlabel('Epoch')
plt.ylabel('Accuracy / Loss')
plt.legend()
plt.title('Validation of the CNN Model')
plt.show()

#--------------------------VALIDATE THE IMAGES------------------------------------------

for i in random.sample(range(len(test_images)), 4):
    plt.imshow(test_images[i])
    plt.title(f"True: {y_true[i]}, Pred: {y_pred_classes[i]}", color='green' if y_true[i]==y_pred_classes[i] else 'red')
    plt.axis('off')
    plt.show()

#--------------------ACCURACY PER CLASS LABEL--------------------------------------------

class_correct = defaultdict(int)
class_total = defaultdict(int)

for true, pred in zip(y_true, y_pred_classes):
    class_total[true] += 1
    if true == pred:
        class_correct[true] += 1

class_accuracy = {k: class_correct[k] / class_total[k] for k in class_total}
plt.bar(class_accuracy.keys(), class_accuracy.values())
plt.xlabel('Class Index')
plt.ylabel('Accuracy')
plt.title('Per-Class Label Accuracy')
plt.show()